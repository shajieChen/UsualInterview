31：内存对齐的方式和为什么要内存对齐

内存对齐的规则： 
1.结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。 
2).结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。 
3).收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的”最宽基本类型成员”的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。 
4).sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。 
原因： 
1.所有的硬件平台都能访问任意地址上的任意数据 
2. CPU对内存的读取操作是对齐的，经过内存对齐后，CPU的内存访问速度大大提升

32：内存泄露的定义、检查、避免

内存泄漏：指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况，也就是申请的堆没有释放 
检测： 
1.检测工具 
2.在任务管理器中观察程序运行时的内存变化情况，逐步注释，找到泄露点 
避免： 
1.养成良好习惯，保证malloc/new和free/delete匹配 
2.不用的内存马上释放 
3.分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表

33：智能指针类

c++中 的智能指针引入一个计数器，每次有对象指向资源时，计数器就加一对象析构时，计数器减一，当计数器的值为0时，对象被释放

template<typename T>
 5 class SmartPointer {
 6 private:
 7     T* _ptr;
 8     size_t* _count;
 9 public:
10     SmartPointer(T* ptr = nullptr) ://构造函数
11             _ptr(ptr) {
12         if (_ptr) {
13             _count = new size_t(1);
14         } else {
15             _count = new size_t(0);
16         }
17     }
        SmartPointer(const SmartPointer& ptr) {//拷贝构造函数
20         if (this != &ptr) {
21             this->_ptr = ptr._ptr;
22             this->_count = ptr._count;
23             (*this->_count)++;
24         }    
25     }

        SmartPointer& operator=(const SmartPointer& ptr) {//赋值操作符
28         if (this->_ptr == ptr._ptr) {
29             return *this;
30         }
31 
32         if (this->_ptr) {
33             (*this->_count)--;
34             if (this->_count == 0) {
35                 delete this->_ptr;
36                 delete this->_count;
37             }
38         }
39 
40         this->_ptr = ptr._ptr;
41         this->_count = ptr._count;
42         (*this->_count)++;
43         return *this;
44     }
        T& operator*() {//*操作符
47         assert(this->_ptr == nullptr);
48         return *(this->_ptr);
49 
50     }
         T* operator->() {//->操作符
53         assert(this->_ptr == nullptr);
54         return this->_ptr;
55     }

        ~SmartPointer() {//析构函数
58         (*this->_count)--;
59         if (*this->_count == 0) {
60             delete this->_ptr;
61             delete this->_count;
62         }
63     }
64 
65     size_t use_count(){
66         return *this->_count;
67     }
68 };

34：程序调试的一般方法

1.插入打印语句 
2.利用输出的内存信息和调试工具打断点 
3.单步执行 
4.看变量赋值是否正确 
5.用工具查找内存泄露 
6.看日志

35：怎么调试coredump

1.ulimit -c unlimited命令设置coredump文件 
2. gdb a.out core命令运行程序（linux下） 
3. 使用bt命令查看堆栈

36：内存检查工具

valgrind（在linux下使用）

37：模板的用法和适用场景

函数模板： Template < class/*typename */ T> 
类模板：template <class/*typename */ T> 
class 类名{ 
}; 
模板中也可以有非模板的参数，如template<typename T, int MAXSIZE>class Stack{ } 
非模板参数可以使常整数，或指向外部链接对象的指针 
注意： 
1.在类定义体外定义成员函数时，若此成员函数中有模板參数存在，则除了须要和一般类的体外定义成员函数一样的定义外，还需在函数体外进行模板声明 
2.在类定义体外初始化const成员和static成员变量的做法和普通类体外初始化const成员和static成员变量的做法基本上是一样的，唯一的差别是需再对模板进行声明 
3. 类模板的使用 类模板的使用实际上是将类模板实例化成一个详细的类。它的格式为：类名<实际的类型>。 
4. 函数模板不能是虚函数 
5. 有时通用的函数模板不能解决个别类型的问题，我们必须对此进行定制，这就是函数模板的特化。函数模板的特化必须把所有的模版参数全部指定。 
场景：一个类中数据成员的数据类型不能确定。或者是某个成员函数的參数或返回值的类型不能确定。就必须将此类声明为模板，它的存在不是代表一个详细的、实际的类，而是代表着一类类。

38：成员初始化列表的概念与优势

以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式，对成员进行初始化。 
构造函数在计算之前的初始化阶段可以对类的成员进行初始化，也就是说对象在代码执行之前被创建。 
初始化列表是创建的时候初始化，而代码内部则实际上是赋值。 
1.const成员或引用成员无法赋值，必须使用初始化列表进行初始化 
2.对于用户自定义的类型来说，该类型在初始化列表中直接调用拷贝构造函数或构造函数，而进入函数体后，则是先调用构造函数，又调用拷贝赋值操作符，所以初始化列表速度快 
3. C++初始化类成员时，是按照声明的顺序初始化的 
4. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化 
5. 子类初始化父类的私有成员，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数

39：c++11的新特性

nullptr 专门代表空指针
auto 自动进行类型推导
引入了基于范围的迭代写法for（auto &i : arr）
初始化列表
引入了外部模板，能够显式的告诉编译器何时进行模板的实例化
可以指定模板的默认参数
引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数
提供了一个匿名函数的特性 
等等
40：c++调用惯例

_stdcall 是StandardCall的缩写，是C++的标准调用方式：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。这些堆栈中的参数由被调用的函数在返回后清除，即由调用者负责把参数压入栈，最后由被调用者负责清除栈的内容，使用的指令是 retnX，X表示参数占用的字节数，CPU在ret之后自动弹出X个字节的堆栈空间。称为自动清栈。函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错

41：c++的四种强制转换

static_cast：完成静态基础类型转换、同一继承体系下的转换（上行安全，下行不安全）、任意类型与空指针void*（或void）之间的转换，主要执行非多态的转换操作，隐式转换都建议使用static_cast进行标明和替换 
dynamic_cast：只有在派生类之间转换时才使用dynamic_cast，转换参数必须是类指针，类引用或者void*。 
使用时基类必须有虚函数，因为dynamic_cast是运行时类型检查，这个信息存在虚表当中，下行转换是安全的，如果不能转换，返回NULL 
const_cast：用于去除指针或引用的常量属性，或赋予常量属性，它是唯一可以对常量操作的转换符 
reinterpret_cast：不到万不得已，不要使用，从底层对数据进行重新解释，依赖具体的平台，可以把整形变成指针，也可以把指针变成数组，也可以在指针和引用之间随意转换，以转化任何内置的数据类型为其他任何的数据类型，实质是对二进制位的操作。


————————————————
版权声明：本文为CSDN博主「wzc2608」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wzc2608/article/details/82115395