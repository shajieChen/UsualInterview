21：C++虚函数相关问题

虚函数表指针： 
占四个内存单元， 指向一个虚函数表的起始位置，这个虚函数表存放着该类的所有虚函数指针，通过该表的偏移即可找到函数的入口地址，即要使用的虚函数。 
虚函数实现原理 
当实例化一个对象时，如果该类没有虚函数，却从其父类哪里继承了虚函数，该类也会有一个虚函数表和一个自己的虚函数表指针，但是表中所存放的虚函数指针却与自己的父类是一样的。 
如果该类定义了从父类继承来的虚函数，同样该类有一个自己的虚函数表和一个自己的虚函数表指针，但是表中这个重写的函数所对应的指针会覆盖掉原来指向父类函数的指针的值，即指向了自己定义的相应函数，表中其它未定义的函数不变 
当使用父类的指针指向子类的对象时，尽管指针的类型是父类的，但它的指向的地址与子类对象地址是同一个，所以它可以从虚函数表指针找到子类对象的虚函数表，进而找到相应的函数；但是如果希望用该指针调用子类自己的函数（非重写的父类虚函数），则编译不过，因为指针的类型是父类，该指针不知道子类空间中自己的变量或函数（非继承自父类）。 
为什么父类的指针能找到子类的虚函数表 
虚函数表指针一般放与首地址，如果父类有虚函数表，子类必定有；因为构造子类时先构造父类，所以使用父类的指针，编译器根据指针类型就能知道偏移多少就能找到父类的成员（包括虚函数指针），但是对于子类独有的成员，父类的指针无法提供偏移量，因此找不到。
多重继承时的虚函数 
多重继承下，派生类有多个虚函数表，也有多个虚函数表指针，数目与所继承的父类的数目相同；这些表的顺序依照声明的顺序来排列，构造的顺序为：父类1的虚函数表，父类1的成员，父类2的虚函数表、父类2的成员…….。子类自己的虚函数（不是继承自任何一个父类的）被放到第一个父类的表中，如果发生虚函数覆盖，则不同表中所有相应的虚函数都被覆盖。当用某一个父类的指针指向派生类时，他们所指向的地址不是子类对象的地址，而是子类中自己的部分，即与自己对应的那个虚函数表。

22：编译器如何处理虚函数表

编译器为每个包含虚函数的类创建一个表，在表中编译器放置特定类的虚函数地址，在每个带有虚函数的类中，编译器为每个类对象放置一个指针（为每个类添加一个隐藏的成员），指向虚表。通过基类的指针或引用做虚函数调用时，编译器静态插入取得该指针，并在虚表中找到函数地址。注意基类和派生类的虚函数表是俩个东西，保存在不同的空间，但这俩个东西的内容可能一样。

23：析构函数、构造函数与虚函数

构造函数是初始化成员变量的函数 
析构函数是在对象的生命周期结束时，完成资源的回收与清理 
当一个类被定义为基类时，一般把析构函数写成虚函数；如果析构函数不是虚函数，当使用基类的指针指向派生类的对象时，只会调用当前对象的析构函数（基类的析构函数），这样就产生了内存泄露；如果是虚函数的话，就会调用所指向对象的析构函数了。 
构造函数一般不定义为虚函数： 
1）虚函数对应一个虚函数表，该表存在对象的内存空间中，调用构造函数时还没有实例化对象，也没有内存空间 
2）构造函数是创建对象时自动调用的，不可能通过父类的指针或引用调用，因此规定构造函数不能为虚函数 
3）在调用构造函数时，不能确定对象的真实类型，它不也不知道自己是否还有后继者，所以它的虚函数指针必须对应这个类的虚函数表，但如果还有一个类继承它，也就是会有一个更晚的构造函数在这之后被调用，它又会设置虚函数指针指向新的虚函数表，虚函数指针被最后的构造函数确定；但在这个过程中，所有的构造函数只能产生通过自己确定的虚函数指针进行调用，而不是最后的虚函数指针，因此无意义。 
构造函数或析构函数中调用虚函数会怎样： 
如上理由3，构造函数中调用的是正在构造的类中的虚函数，而不是子类的最终的虚函数，实际上无意义。另外如果所调用的函数操作了还没有被初始化的成员，可能导致灾难性的结果。同样的在析构函数中的调用也没有意义。实际上在构造函数和析构函数中调用虚函数并不是虚调用，而是实调用，调用的就是指针的类型所对应的函数，一般情况下，应该避免在构造函数和析构函数中调用虚函数。

24：纯虚函数

纯虚函数的声明是虚函数声明后加=0，定义纯虚函数代表函数没有被实现；含有纯虚函数的类被称为抽象类，它不能生产对象，纯虚函数必须在继承类中重新声明，他们在抽象类中没有定义；纯虚函数的目的在于使得派生类仅仅继承函数的接口。如果纯虚函数在派生类中没有被改写，那么该派生类也是抽象类。 
纯虚函数的使用： 
该方法只希望被继承，不能被实例化 
该方法必须在派生类中实现

25：静态绑定和动态绑定

对象的静态类型： 
对象在声明时采用的类型，编译期确定 
对象的动态类型： 
目前所指的对象的类型，运行期确定。 
动态类型可能改变，静态类型不会改变 
静态绑定： 
绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期 
动态绑定： 
绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期 
指针和引用的动态类型和静态类型可能会不一致，但是对象的动态类型和静态类型是一致的 
只有虚函数才使用的是动态绑定，其他的全部是静态绑定 
不要定义继承来的虚函数的缺省参数值，因为虚函数是动态绑定，参数是静态绑定，会出现调用子类的函数可能使用的是父类的参数。

26：引用与动态绑定

引用可以实现动态绑定，因为对象的类型在编译期就确定了，而引用在运行期根据它所绑定的东西而确定。

27：深拷贝与浅拷贝的区别与安全性

浅拷贝：将一个对象赋值给另外一个对象的时候，如果只是进行数据成员间值的简单拷贝，而没有资源的重新分配 
深拷贝：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，而非单独赋值

在某些情况下，类内成员变量需要动态开辟堆内存（比如指针），如果简单的赋值（比如俩个指针指向一块内存），那么当一个对象释放内存之后，其它对象就会出现错误。 
注意：在写拷贝构造函数时，只能传参，不能传值，因为传值本身就是拷贝过程 
默认的拷贝构造函数都是浅拷贝 
安全性：深拷贝更安全，浅拷贝在释放资源的时候会产生资源归属不清的情况。

28：对象复用与零拷贝

对象池：对象池通过对象复用的方式来避免重复创建对象，它会事先创建一定数量的对象放到池中，当用户需要创建对象的时候，直接从对象池中获取即可，用完对象之后再放回到对象池中，以便复用。 
适用性：类的实例可重用。类的实例化过程开销较大。类的实例化的频率较高的时候可以使用对象复用。 
零拷贝：避免CPU将数据从一快存储拷贝到另外一块存储的技术，比如emplace_back函数

29：c++中的构造函数

构造函数的名称与类名完全相同，且不反回任何类型。 
1.默认的构造函数，默认的构造函数是没有任何参数的，如果类中没有声明构造函数，将由编译器提供，一旦声明了任何非默认构造函数，编译器将不再提供 
2.复制（拷贝）构造函数，采用相同对象类型的引用作为输入，并创建一个它的副本，编译器会提供一个复制构造函数，但是是浅拷贝。 
3.普通派生类的构造函数：会按继承时的声明顺序构造基类 
4.含有虚继承的派生类构造函数，创建所有有参构造函数的基类，包括直接基类，间接基类

30：调用拷贝构造函数的情况

1.直接初始化和拷贝初始化时（直接初始化就是赋值，最好使用初始化列表而不是直接初始化） 
2.把一个对象作为实参传递给一个非引用非指针类型的形参 
3.返回一个非引用非指针类型的对象 
4.用花括号初始化列表初始化一个数组的元素或聚合类的成员
————————————————
版权声明：本文为CSDN博主「wzc2608」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wzc2608/article/details/82079408