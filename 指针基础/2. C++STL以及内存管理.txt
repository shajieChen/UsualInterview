11.sizeof的用法

sizeof的作用是返回一个对象或类型所占用的内存字节数。 
1.对于简单内置类型如int、float等，它们的大小与内存相关；关于在不同的机器中它们到底占多少个字节，见字节数 
2.对于结构体和类，它们在内存中所占的字节数涉及到对齐的问题： 
编译器默认对结构体进行处理，让宽度为2的基本数据类型都位于能被2整除的地址上，让宽度为4的数据类型处在能被4整除的地址上；这样俩个数之间可能需要填充字节，整个结构体的sizeof值就增长了。一般而言，字节对齐满足三个原则： 
a.结构体变量的首地址能够被其最宽基本类型成员的大小所整除 
b.结构体的每个成员相对结构体首地址的偏移量都是成员大小的整数倍 
c.结构体的总大小为结构体最宽基本类型成员大小的整数倍 
空结构体的sizeof值为1，编译器为空的类和结构体分配一个字节的空间用于占位； 
3.联合体的sizeof是每个成员的sizeof的最大值 
4.数组的sizeof为数组所占用的内存字节数，当数组为形参时，sizeof的值相当于指针的sizeof 
5.指针的sizeof大小等于计算机内部地址总线的宽度（32位机器为4），与所指对象无关 
6.函数的sizeof是函数返回值的大小，函数本身不被调用；不可以对返回值类型为空的函数求大小，不可以只对函数名求值，带参数的函数必须写上实参表 
7.类的sizeof的影响因素有： 
a>非静态数据成员的大小，静态成员在静态存储区分配了内存空间，而类的对象分配在堆上，所以在计算大小时，不计算静态成员。 
b>数据成员的顺序，数据成员的顺序之所以会影响类的大小，是因为对齐方式不同，比如int a; short b; char c 对齐之后大小为8，short b; int a; char c 对齐之后为12 
c>字节校正与对齐，同上 
d>基类的大小，子类的大小受父类的影响，因为子类继承了父类的成员 
e>是否存在虚函数，类中有虚函数会增加4(32位)/8（64位）个字节，不管有多少个虚函数（可以是自己的也可以是继承的），只增加4(32位)/8（64位）个字节；因为只有一个虚函数表。 
f>使用的编译器 
g>继承模型，是否是虚继承，在虚继承的情况下，还要额外添加一个虚指针（4(32位)/8（64位）），但同样需要注意一个函数只有一个自己的虚指针；也就是说如果B虚继承A，C虚继承A，D继承B,C则只算一个虚指针的大小；如果B虚继承A，C虚继承D，E继承B，C则需算俩个虚指针。

例：

class A {}; sizeof(A) = 1；
class A {virtual fun()}; sizeof(A) = 4(32位)/8（64位）
class A {static int a;}; sizeof(A) = 1;
class A {int a}; sizeof(A) = 4;
class A {static int a; int b;}; sizeof(A) = 4
1
2
3
4
5
12.C++ STL简单介绍

STL是对泛型编程思想的实现，从广义上分为三类：算法、容器、迭代器。其中算法部分主要有<algorithm>、<numeric>、<functional>组成，实现了常用的算法；容器主要实现了一些数据结构如向量、列表等，迭代器是一种允许程序员检查容器内元素，并实现元素遍历的数据类型；C++为每一种标准容器定义了一种迭代器类型，提供了比下标操作更加一般化的方法。

13.STL源码中hash表的实现

1.哈希表是一种根据关键字直接访问内存的数据结构，通过哈希函数将键值映射为内存中的位置；哈希表可能遇到碰撞的情况，碰撞是指俩个不同的键值映射到了同一块内存区域；STL中使用开链法解决碰撞；当发生碰撞时，使用链表进行连接。 
2.STL哈希表的每一个哈希节点中有数据和next指针，哈希表定义时要指定数组大小n，但是实际分配的数组长度是根据n计算的一个质数；在STL中存在一个计算好的质数表，只要找到第一个大于n的质数就可以；如果要放入哈希表的个数大于哈希表的长度，那么必须对哈希表的大小进行重新分配，每次重新分配的大小差不多是之前的二倍；如果发生碰撞，新的元素将放在链表中第一个元素的前面，成为链表中的第一个节点； 
3.STL中使用的哈希函数是简单的对数组的长度取余（M_hash（key）% n），其中M_hash 除了对字符串进行转换之外其它都返回原值。

14.STL中unordered_map和map的区别

map： 
map是STL内的一个关联容器，它提供一对一的数据处理能力，map内部自建一颗红黑树，该结构具有自动排序功能，因此map内的所有数据都是有序的，且map的查询、删除、插入的时间复杂度都是O(logN)。在使用时，map的key必须定义有operator < （<操作符）。 
map的优点是时间复杂度好，效率高，且内部元素有序；缺点是空间占用率高。 
unordered_map： 
unordered_map与map类似，都是存储key-value的值，可以通过key快速找到value，不同的是unordered_map不会根据key的大小排序，存储时根据key的hash值判断元素是否相同。unordered_map的key需要定于hash_value并重载operator ==。 
unordered_map的底层是一个防冗余的哈希表。 
unordered_map的优点是查找速度快，缺点是建立哈希表比较耗时

15.STL中vector的实现

vector采用的数据结构时线性连续的空间，它内部维护有三个迭代器，其中start指向连续空间中已经被使用的空间的开头，finish指向已经被使用空间的尾部，而end_of_storage指向整个连续空间的尾部；因此vector的大小size表示已经使用的空间大小（已有元素的个数），容量capacity表示vector本身连续空间的大小（最多可存储元素的个数），当size等于capacity时，若要再加入新的元素，要重新进行内存分配，整个vector数据都将移动到新内存，新分配的内存一般为原来大小的俩倍。所以程序员使用vector不需要提前知道内存大小。 
一旦重新分配内存，指向原vector的迭代器会全部失效。

16.vector使用的注意点及其原因，频繁调用vector的push_back对性能的影响和原因

注意点及原因： 
1.vector支持随机存取，因为它存在连续的空间中 
2.末端增加或删除元素，vector的性能相当好，但是在前端增加或删除元素性能差，因为每次在前端做增删，它后面的元素也必须前移或后移。 
3.合适的vector大小很重要，因为每次内存重新分配和其相关的引用、指针、迭代器都会失效，且分配内存很耗时 
4.谨慎的在小索引上插入或删除元素，因为这样做会使该点之后的引用、指针、迭代器全部失效，如果引起重新的内存分配，则该vector上的所有引用、指针、迭代器都会失效。 
5.vector只有at()函数会做检查，其它函数都不做检查，如果越界读取，会有未定义行为 
频繁调用vector的push_back对性能的影响和原因： 
一旦push_back引起空间重新配置，则指向原vector的所有迭代器失效

17.c++重载与重写的区别

重载： 
指函数名相同，但是它们的参数表列个数或顺序、类型不同。但不能靠返回类型来判断 
1.相同范围 
2.函数名相同 
3.参数不同 
4.virtual关键字可有可无 
5.返回值可以不同 
重写： 
指派生类重新定义基类的虚函数 
1.不在一个作用域中 
2.函数名相同 
3.参数相同 
4.基类函数必须有virtual关键字，不能有static，因为静态方法不可重写 
5.返回值相同或协变（协变指，当返回指针或引用时，子类中重写函数返回的指针或引用是父类中被重写函数所返回的指针或引用的子类型） 
6.函数重写的话const关键字也必须相同 
7.重写函数所抛出的异常必须和被重写函数抛出的异常一致，或是其子类 
8.重写函数的访问修饰符可以不同与被重写函数，即private、public、protected都可以

18.C++内存管理

1.内存分配机制及堆栈的区别（见问题2） 
2.new和delete（见问题3），注意C++允许对new和delete进行重载 
3.常见的内存管理错误有 
a>内存分配未成功却使用了它，如果所用的操作符不是类型安全的话，请使用assert(p != NULL)或者if(p != NULL)来判断。 
b>内存分配成功但未初始化 
c>内存分配成功并已初始化，但是操作超过了内存的边界 
d>忘记释放内存，造成内存泄露，每申请一块内存必须保证它被释放，释放内存后立即将指针置为NULL 
4.数组与指针的对比，数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。 
指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

19.面向对象的特性有哪些，请举例说明

1.封装，所谓封装是指把客观事物封装成抽象的类，类可以把自己的数据和方法只让可信的类或对象操作且，隐藏其实现细节 
2.继承，指某一个类型的对象获得另一个类型对象的属性和方法，继承可以使用现有类的所有功能并在无需重写原来类的情况下，对这些功能进行扩展；通过继承创建的心累被称为子类或者派生类，被继承的类叫做基类，父类或超类；继承有俩种实现方向： 
a>实现继承：指使用基类的属性和方法而无需额外编码 
b>接口继承：仅仅使用属性和方法的名称，子类必须提供实现的能力 
3.多态，指一个类实例的相同方法在不同情形下有不同的表现形式（允许将子类类型的指针赋值给父类类型的指针）。多态机制可以使得不同内部结构的对象可以共享相同的外部接口。多态实现的方法有重写（见问题17） 
总结：封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！

20.多态的实现

c++的多态性是在基类的函数前加virtual关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，那么就调用派生类的函数；如果对象是基类，那么就调用基类的函数。 
1.用virtual关键字声明的函数叫虚函数，虚函数一定是类的成员函数 
2.存在虚函数的类都有一个一维的虚函数表叫虚表，类的对象有一个指向虚表开始的虚指针；虚表和类对应，虚指针与对象对应。 
3.多态性是一个接口的多种实现，分为类的多态性和函数的多态性实现 
4.多态用虚函数来实现，结合动态绑定 
5.纯虚函数是指虚函数加=0； 
6.抽象类指包括至少一个纯虚函数的类。 
.7.函数的多态性指一个函数被定义为多个不同参数的函数，当调用时，就会调用不同的同名函数。（即函数的重载）
————————————————
版权声明：本文为CSDN博主「wzc2608」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wzc2608/article/details/80048553