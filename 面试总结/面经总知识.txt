玩过什么游戏：
    大部分以2D RPG/3D RPG 游戏为主 
    3D的游戏印象深有国产的风卷残云 ， 爱丽丝疯狂回归，神秘海域之类的
    2D 雨血1， 莫塔守山人 以及其他手机游戏 
C++：
    - Define 和 Inline 区别 
        inline编译期间展开，  define预处理阶段展开
        类型安全问题inline比较安全，inline会进行类型检查，define不会
        inline 函数是函数， define 宏只是定义 
        const、enum、inline替换#define
    - 构造函数不能定义为虚函数
        构造函数是在创建对象时自己主动调用的，不可能通过子类的指针或者引用去调用。
    - 析构函数为什么是虚函数
        析构函数不被声明成虚函数，则编译器采用的绑定方式是静态绑定，在删除基类指针时，只会调用基类析构函数，而不调用派生类析构函数，
        这样就会导致基类指针指向的派生类对象析构不完全。若是将析构函数声明为虚函数，则可以解决此问题
    - 虚函数 和 纯虚函数
        （虚函数）： 
            只含有虚函数的类(class)不能被称为抽象类(abstract class)
            虚函数必须实现，如果不实现，编译器将报错，
            虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数
            *虚函数实现：
                对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。
                简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。
                这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，
                它就像一个地图一样，指明了实际所应该调用的函数。

                这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（
                这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。
                
                虚函数表应该是在编译期确定的
        （纯虚函数）：
            有纯虚函数的类被称为抽象类
            抽象基类(ABC)是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法
            实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定
        （区别）：
            纯虚函数只有定义，没有实现；而虚函数既有定义，也有实现的代码
            包含纯虚函数的类不能定义其对象，而包含虚函数的则可以。
            虚函数的定义形式：virtual {method body}
        　 　纯虚函数的定义形式：virtual { } = 0;
        （相同点）：
        虚函数和纯虚函数都可以在子类(sub class)中被重载，以多态的形式被调用。
    - const 
        规则：const离谁近，谁就不能被修改； 
        const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。 
        本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。

        需先初始化，以后就没有机会改变他了void function()const; //常成员函数, Const成员函数不能改变类的成员变量
    - 常见影响C++ 性能的因素
        函数调用的开销是要考虑的一个因素，因此我们应该将短小的、频繁调用的函数内联；
        复制对象的开销是高昂的，最好选择传递引用，而不是传递值。
    - 多态实现 
        编译时多态性，运行时多态性。
            a.编译时多态性：通过重载函数实现
            b 运行时多态性：通过虚函数实现。
        表现形式：
            （1）静态多态（重载，模板）是在编译的时候，就确定调用函数的类型。
            （2）动态多态（覆盖，虚函数实现）在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。
    - 重载、覆盖和隐藏的区别
        1、重载：
            适用于不同的数据类型都需要使用到的功能函数。
        2. 覆盖：
            只能在类的继承中使用。适用于父类和子类都要实现的成员函数，
            且该函数需要在运行中动态绑定的，这个函数就是虚函数，在动态绑定中子类的虚函数把父类的覆盖了。
        3. 隐藏
            是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
        重载和重写的区别：
        （1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
        （2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
        （3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。
        隐藏和重写，重载的区别：
        （1）与重载范围不同：隐藏函数和被隐藏函数在不同类中。
        （2）参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。  
    - 动态绑定 / 静态绑定
        *对象为类的实例
       静态绑定发生在编译期，动态绑定发生在运行期；
       对象的动态类型可以更改，但是静态类型无法更改；
       在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；
       绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36）
            ，因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；
    - 静态变量的存储方式 处于全局数据区
        外部变量(extern)和静态变量(static)属于静态存储方式
        静态数据成员要实际地分配空间，不能在类中定义，不能在头文件中类声明的外部定义
        static被引入以告知编译器，将变量存储在程序的静态存储区而非栈上空间
        静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套时，要保证所嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序
        静态局部变量只对定义自己的函数体始终可见
        1）全局变量是不显式用static修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern 全局变量名的声明，就可以使用全局变量。
        2）全局静态变量是显式用static修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用extern声明也不能使用
    - 内存分配机制
        1. 栈区（stack）： 存放局部变量名；
        2. 堆区（heap）： 存放new或者malloc出来的对象；若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 
        3. 文字常量区： —常量字符串就是放在这里的。 程序结束后由系统释放
        4. 全局区（静态区）（static）： 用于存放全局变量或者静态变量；
        5. 代码区：二进制代码。
        C/C++不提供垃圾回收机制，因此需要对堆中的数据进行及时销毁，防止内存泄漏，使用free和delete销毁new和malloc申请的堆内存，而栈内存是动态释放。
    - 多继承命名冲突
        虚继承（Virtual Inheritance，为了解决多继承时的命名冲突和冗余数据问题 virtual public 
    - 指针和引用的区别与相同点
        指针是一种数据类型，是无符号整数，不过这个整数有特殊意义，它代表着内存编号。
        引用就是某一变量（目标）的一个别名
        （引用和指针的相同点）
        1、指针和引用都可以优化传参效率
        2、都是地址的概念；指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。

        （引用和指针的不相同点）
        1、指针占内存空间，引用不占内存空间
        2、指针可以为空，但是引用不能为空
        3、指针可以不初始化，但是引用必须初始化
        4、指针可以有多级，但是引用只能是一级（int **p合法但是int &&a是不合法的）
        5、指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了，从一而终。
        6、指针是一种变量，而引用只是引用。
    - sizeof 所有相关信息
        Sizeof(引用)计算的是它引用的对象的大小，而sizeof(指针)计算的是指针本身的大小。
        int 就只占4个字节，char 就只占一个字节，与系统无关
        32位系统 一个地址占32位二进制空间，sizeof(double *)==sizeof(int *)==sizeof(char *)==32/8==4   
        64位系统 sizeof(double *)==sizeof(int *)==sizeof(char *)==64/8==8
        编译器为兼容，指针都是4个字节长度 
    - new和malloc 区别
        1.属性
        new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。
        2.参数
        使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
        3.返回类型
        new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。
        而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
        4.分配失败
        new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
        5.自定义类型
        new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。
        delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
        malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
        6.重载
        C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，
        new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。
        7.内存区域
        new操作符从自由存储区（free store）上为对象动态分配内存空间，
        而malloc函数从堆上动态分配内存。
        自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
        而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
    - C++新特性
         auto 和 decltype 这两个关键字实现了类型推导
         （Lambda 表达式）
            提供了一个类似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。
            [ caputrue ] ( params ) opt -> ret { body; };
                1) capture是捕获列表； 
                2) params是参数表；(选填) 
                3) opt是函数选项；可以填mutable,exception,attribute（选填） 
                mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。 
                exception说明lambda表达式是否抛出异常以及何种异常。 
                attribute用来声明属性。 
                4) ret是返回值类型（拖尾返回类型）。(选填) 
                5) body是函数体         
            关于捕获列表
                捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。
                1) []不捕获任何变量。 
                2) [&]捕获外部作用域中所有变量，（按引用捕获）。 
                3) [=]捕获外部作用域中所有变量，(按值捕获)。注意值捕获的前提是变量可以拷贝，且被捕获的变量在 lambda 表达式被创建时拷贝，
                而非调用时才拷贝。如果希望lambda表达式在调用时能即时访问外部变量，我们应当使用引用方式捕获。
    - 智能指针 
        unique_ptr
            unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象
        shared_ptr    
            shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放
        weak_ptr
            一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象
            weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作
            两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏
    - 关于STL   
        STL包含6大部件：容器、迭代器、算法、仿函数、适配器和空间配置器。


        迭代器 -- 指针
        *容器
        关联容器分为set和map
        顺序容器 vector(空间连续)，list(空间不连续但是空间不浪费)，   
        vector
            vector底层是一个动态数组，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。
            增加两倍大小的原因：vector的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为vector的空间是线性连续分配的，不能保证原空间之后有可供配置的空间
            当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。
            因此，对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器会都失效了。
            （3）vector中的size和capacity的区别
             size表示当前vector中有多少个元素（finish - start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）。
            （4）vector的元素类型可以是引用吗？
            vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。
            （5）vector迭代器失效的情况 
            当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。 
            当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。 
        List 
            List则对空间的运用有绝对的精准，一点也不浪费。注意，list内部构成的实际是一个环状的双向链表！所以只需要一个指针，便可以完整地表现整个链表。
            （1）list的底层原理
              list的底层是一个双向链表，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。 
              list不支持随机存取，如果需要大量的插入和删除，而不关心随即存取
        Deque
            Deque相比于vector而言，它没有容量的概念，因为deque是动态地以分段连续空间组合而成，随时都可以增加一段新的空间并链接起来
            。为了使得deque在逻辑上看起来是连续空间，在STL内部实现实际是使用了一块map(不是STL中的map容器)作为主控
            ，map是一小块连续空间，其中每个元素都是指针，指向另一段较大的连续线性空间，称为缓冲区，这些缓冲区才是真正存放deque元素的主体。
        Stack
            Stack在缺省的情况下是使用deque作为底部结构，只需要封闭deque一端的操作即可，也可以指定其他的容器作为底部结构，例如list。
        heap
        priority_queue，
        Hash_set

        hash_map
        map
            1，map简介
            map是STL的一个关联容器，它提供一对一的hash。
            第一个可以称为关键字(key)，每个关键字只能在map中出现一次；
            第二个可能称为该关键字的值(value)；
            map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。
            Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。
            在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。

        std::array 保存在栈内存中，相比堆内存中的 std::vector，我们能够灵活的访问这里面的元素，从而获得更高的性能。

算法：
    - A*
    - 最短路径
    - 排序种类选择情况
    - 无序排序找出第二大值
        快速选择
    - 深度优先和广度优先
        DFS / BFS
    - 如何判断点在圆内， 如何判断在矩形内
        距离 / 叉乘 
    - 链表 数组优缺点
        一、数组的优点
        随机访问性强，查找速度快 
        二、数组的缺点
        1、对内存的要求高，必须要连续的内存空间
        2、插入和删除的效率比较低  
        3、数组大小固定，动态拓展性差，而且可能浪费内存

        三、链表的优点
        1、对内存的要求低
        2、大小可以不固定，内存的利用率比较高
        3、插入和删除方便 
        四、链表的缺点
        查找效率低，不可以随机查找，每次查找必须从头开始 
    - hash_map的复杂度和实现原理 
        常见的
        数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，
                当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)
　      线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)
　      二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。
　      哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，
                性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)
        hashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。
    - 冒泡和快排平均事件复杂度 
        O（n的平方） O(n的平方)
    - 链表linked list 是否带环 
          判断链表是否有环的经典的方法是快慢指针的方法。 
          快指针pf每次移动两个节点，慢指针ps每次移动一个节点，如果指针可以追上慢指针，那就说明其中有一个环，反之没有。 
          结论：链表存在环，则fast和slow两指针必然会在slow对链表完成一次遍历之前相遇。
网络：
    - 三次握手
        TCP握手协议 
        在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.
        第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；  SYN：同步序列编号(Synchronize Sequence Numbers)
        第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 
        第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.
        完成三次握手,客户端与服务器开始传送数据
    - 四次挥手
        （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
        （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
        （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
        （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

    1、TCP是面向连接的（在客户端和服务器之间传输数据之前要先建立连接），UDP是无连接的（发送数据之前不需要先建立连接）
    2、TCP提供可靠的服务（通过TCP传输的数据。无差错，不丢失，不重复，且按序到达）；UDP提供面向事务的简单的不可靠的传输。
    3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性比较高的通讯或广播通信。随着网速的提高，UDP使用越来越多。
    4、没一条TCP连接只能是点到点的，UDP支持一对一，一对多和多对多的交互通信。
    5、TCP对系统资源要去比较多，UDP对系统资源要求比较少
    6、UDP程序结构更加简单
    7、TCP是流模式，UDP是数据报模式 

    　跟TCP相比，UDP少了listen、accept、connect。也就是少了三次握手。


渲染：
    渲染流程在概念性阶段可以分为三个阶段：应用阶段(Application Stage), 几何阶段(Geometry Stage), 光栅化阶段(Rasterizer Stage)。

        应用阶段--------->输出渲染图元-------->几何阶段-------->输出屏幕空间的顶点信息-------->光栅化阶段
    应用阶段: 
        这个阶段由应用主导，通常由CPU负责实现，开发者对这个阶段有绝对控制权 
        任务：准备场景数据，摄像机位置，视椎体， 场景中包含的模型，使用的光源等等 。
        粗粒度的遮挡剔除处理 。最后设置每个模型的渲染状态，包括但不限于使用的材质，使用的纹理，使用的Shader 。
        这一阶段最重要的是输出渲染所需的几何信息，即渲染图元 ，通俗的讲：渲染图元可以是点 线 三角面等，这些渲染图元会传送给几何阶段
    几何阶段
        顶点着色器：完全可以编程的，通常实现顶点的空间变换，顶点着色等功能
        曲面细分着色器：可选的着色器 用于细分图元
        几何着色器：可选的着色器 用于执行逐图元的着色，或者产生更多的图元
        裁剪：可配置的 将那些不在摄像机视野的顶点裁剪掉，并删除某些三角图元的面片
        屏幕映射：可配置和编程 负责将每个图元的坐标转换到屏幕坐标系 
    光栅化阶段  
        三角形设置
        三角形遍历
        片元着色器： 完全可编程的 实现逐像素的着色操作
        逐片元操作：高度可配置的 执行许多重要功能 修改颜色 深度缓冲 混合操作

    三角形与渲染流水线
        (顶点变换后的顶点着色)(图源转装配 变成三角形模样)(光栅化)(插值贴图着色)

    背面剔除在光栅化阶段进行,执行在Vertex Shader 之后,在Fragment Shader片元着色器之前。

    CPU与GPU之间的通信 
    渲染流水线的起点是CPU  1.将数据加载到显存中    2.设置渲染状态    3.调用DrawCall来进行一次绘制
        1网格纹理等数据加载到显存中 显卡访问显存的速度比加快
        2设置渲染状态  定义：定义了场景中的网格是怎么被渲染的 (使用哪个shader ，材质，光源属性等)
        3调用DrawCall    DrawCall 是一个命令 是由CPU发起的，接收方GPU GPU会根据渲染状态和所有输入的顶点数据进行计算最终生成像素点

    PBR 与普通渲染
        pbr和原始的blinn-phong的最大区别就是，考虑到了光照的能量守恒，且 基于给定粗糙值的表面(片元)，对于光的反射计算更加的符合统计结果。

        基于粗糙度，入射方向，观察方向，法线方向，先使用一个统计模型去估算出对于此片元来说，
        法线半球内所有入射光线经过直接反射进入到观察者眼睛的占比，也就是高光的占比（并根据法线分布函数和几何函数做调整）（在不考虑基于环境cubemap作为间接光源的情况下，
        单个直接光源对单个片元来说只需要计算一根入射光线，phong里就是这样，但是他没有能量守恒）。
        随后漫反射的占比就能通过1减去高光占比简单的算出来 （此为能量守恒）（折射进入物体后被吸收或二次散射出来，即表现为漫反射）(当然最后还是需要乘以熟悉的Dot(n,l))。

        菲涅尔函数：获取反射光总量的占比 (也就同时得到了漫反射占比)
        法线分布函数：通过粗糙度常量和dot(n,h)的函数获得高光值...越光滑的表面，高光越集中、亮，反之，高光面积越大且越暗
        几何函数:获取由于微表面的相互遮蔽，而造成的能量损失概率。

    MipMap原理
        （1. 选择采样方法）
        第一个步骤为选择合适的下采样方法来生成mipmaps。在图像学中，图像缩小时产生的混叠常用一些低通滤波器来减轻，即在缩小前先将图像做一个低通滤波。
            这个滤波器有多种选法，简单的可以是box平均滤波，复杂点可以是各向异性的滤波器，它常是由某些偏微分方程的数值解得到的，好处是在平滑的同时可以保持边缘的清晰度。这些在mipmapping中也可以使用，一般来说，我们都使用简单的box filter即可。
        （2. 计算缩小比例）
        第二个步骤就是计算缩小比率d，这是算法中的关键。这个算法也有好几类，我使用的是将像素看做是正方形的那一类，也是ES spec上给出的算法，
            即： d = sqrt( max((Ux^2 + Vx^2) , (Uy^2 + Vy^2)) );
            为了去掉乘法和开根号的运算，我又将其简化为：d = max((Ux + Vx) , (Uy + Vy));这个也满足spec上的要求。另一方面，如果对三角形中的每点都计算d，那就太费时间，所以就只对整个三角形算出一个d值，在内层循环中只对d做透视修正和下面的第三个步骤。如果是正投影，那内层循环就没有增加任何计算量。
        （3. 选择贴图类型d 最近/线性） 
        第三个步骤是根据d值确定选取哪一个mip做贴图对象。这个很简单，如果是linear_mipmaps_nearest，那么level = floor(log2(d+0.5))；
            如果是linear_mipmaps_linear，level = floor(log2(d))； fraction = d - floor(log2(d))；用level层和level+1层的数据用fraction做混合后在贴图。

    常见光照模型
        - Lambert 模型
        - Phong 模型 （环境/漫反射/高光） 
        - Blinn-Phong 光照模型
        - 全局光照模型
    合批
        1.静态合批是将静态（不移动）GameObjects组合成大网格，然后进行绘制。
        2.动态合批是将一些足够小的网格，在CPU上转换它们的顶点，将许多相似的顶点组合在一起，并一次性绘制它们。


https://blog.csdn.net/yinhun2012/article/details/80015565
        https://www.cnblogs.com/wxquare/p/6847505.html