Unity 相关面试 

1. hash 相关
    1、什么是hash?
        Hash：是一种信息摘要算法，它还叫做哈希，或者散列。我们平时使用的MD5,
        SHA1都属于Hash算法，通过输入key进行Hash计算，就可以获取key的HashCode()，比如我们通过校验MD5来验证文件的完整性。
        对于HashCode，它是一个本地方法，实质就是地址取样运算 
    2、什么是碰撞？ 
        好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞; 
        就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。
    3、“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” 
        HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射
        HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
        HashMap 是非 synchronized，所以 HashMap 很快
        HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）
        HashMap 是基于 hashing 的原理 
        以下是具体的 put 过程（JDK1.8）  
            对 Key 求 Hash 值，然后再计算下标
            如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）
            如果碰撞了，以链表的方式链接到后面
            如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
            如果节点已经存在就替换旧值
            如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排） 

2. GC
    能简单聊一下垃圾收集的工作方式吗？ 
        运行.NET应用程序时，程序创建出来的对象都会被CLR跟踪， 
        哪些对象还会被用到（存在引用关系）；哪些对象不会再被用到（不存在引用关系），CLR都是有记录的。 
        CLR会整理不会再被用到的对象，在恰当的时机，按一定的规则销毁一部分对象，释放出这些对象所占用的内存。
       - CLR是怎么记录对象引用关系的？ 
            CLR会把对象关系做成一个“树图”，这样标记他们的引用关系 
       - CLR是怎么释放对象的内存的？ 
            关键的技术是：CLR把没用的对象转移到一起去，使内存连续，新分配的对象就在这块连续的内存上创建，这样做是为了减少内存碎片（CLR不会移动大对象）
    垃圾收集器按什么规则收集垃圾对象？ 
        CLR按对象在内存中的存活的时间长短，来收集对象。
        时间最短的被分配到第0代，最长的被分配到第2代，一共就3代。
        一般第0贷的对象都是较小的对象，第2代的对象都是较大的对象
        第0代对象GC收集时间最短（毫秒级别），第2代的对象GC收集时间最长。
        当程序需要内存时（或者程序空闲的时），GC会先收集第0代的对象，
        收集完之后发现释放的内存仍然不够用，GC就会去收集第1代，第2代对象。（一般情况是按这个顺序收集的）
        如果GC跑过了，内存空间依然不够用，那么就抛出了OutOfMemoryException异常。
        GC跑过几次之后，第0代的对象仍然存在，那么CLR会把这些对象移动到第1代，第1代的对象也是这样。
    既然有了垃圾收集器，为什么还要Dispose方法和析构函数？ 
        因为CLR的缘故，GC只能释放托管资源，不能释放非托管资源（数据库链接、文件流等） 
        那么该如何释放非托管资源呢？
        一般我们会选择为类实现IDispose接口，写一个Dispose方法。
        让调用者手动调用这个类的Dispose方法（或者用using语句块来调用Dispose方法）
        这是不错的选择，因为调用者最清楚该什么时候来释放这些资源。
        这个方法执行时，析构函数和垃圾收集器都还没有开始处理这个对象的释放工作
    我们需要手动执行垃圾收集吗？什么场景下这么做？ 
    GC何时执行垃圾收集是一个非常复杂的算法（策略） 
        大概可以描述成这样： 
        如果GC发现上一次收集了很多对象，释放了很大的内存， 
        那么它就会尽快执行第二次回收， 
        如果它频繁的回收，但释放的内存不多， 
        那么它就会减慢回收的频率。 
        所以，尽量不要调用GC.Collect()，这样会破坏GC现有的执行策略。 
        除非你对你的应用程序内存使用情况非常了解，你知道何时会产生大量的垃圾，那么你可以手动干预垃圾收集器的工作  
        我有一个大对象，我担心GC要过很久才会收集他，
    简单聊一下弱引用和垃圾收集之间的关系？ 
        假设有一个大对象，用完之后引用关系就没有了，这个时候GC随时都有可能收集它，并释放他占用的内存 
        但因为是一个较大的对象，很有可能在第3代，估计GC一时半会还不会去收集它。 
        这个对象已经在垃圾堆里了，但是我还想用它，怎么办？怎么从垃圾堆里把它捞回来呢？ 
        这个时候就用到了弱引用，来看看下面这段代码： 
        varbss = newBsCtl(BrowserContainer);             varvbss = newWeakReference<BsCtl>(bss);             bss = null;             BsCtl ok;                         vbss.TryGetTarget(outok);             //如果没有进行垃圾收集OK不会为NULLif(ok == null)             {                 //如果已经进行了垃圾收集，就会执行这段代码ok = newBsCtl(BrowserContainer);             }
        垃圾收集随时可以收集bss对象， 
        如果收集了，就会进入if语句块，如果没有收集，就不会进入if语句块，TryGetTarget(out ok)就成功把bss从垃圾堆里捞回来了
 

3. 阴影 
     一般来说，在游戏中，应用比较多的影子技术有三种，Projective Shadow、 Shadow Map以及Shadow Volume。我们接下来便依次的介绍它们。

    1、阴影算法的任务 
        shadow map（以及shadow volume）等shadow算法，到底是做什么的？这其实是需要解决的第一个问题。这些阴影算法的核心，实际上就是要针对任意给定的一个物体片段点（fragment point），鉴定出它是否处在阴影之中。
        所以阴影算法，归根结底是要给出这样一个函数： 
        bool ShadowAlgorithm(vector3 fragmentPoint) {
            if ( IsInShadow(fragmentPoint) )
                return true;
            else
                return false;
        }
        各种不同的阴影算法，实际上就是“是否在阴影中”的鉴别方法不同。 
    2、阴影产生的自然原理 
            什么样的点是在阴影中的？看看下面这张图 
                图1、阴影（图中橘黄色的是不透明的物体） 
            在平行光的照射下，直觉的可以知道，点A、点D在阴影之外，而点B、点C在阴影之中。
                直觉判断的依据，就是由于光线的直线传播特性，一旦遇到遮挡，就会产生阴影。换言之，对于光线来说不可见的点，就是在阴影中的点。
            那么上面的判断函数 IsInShadow，就可以进一步写为如下的伪代码： 
                bool IsInShadow(vector3 fragmentPoint) {
                    return !IsVisibleToLight(fragmentPoint, mLight);
                }
            其中 mLight是需要生成阴影的平行光，fragmentPoint是需要进行判断的片段点。
    3、基于自然原理的提炼：light space 的 shadow depth map 
            一提到这种可见性的判定，自然的就会想到 depth test。我们站在光源的位置，按照光线传播的视角，观察场景，
                计算场景中的物体距离光源的距离（也就是该视角下的深度），并记录各个位置上的最小值（即距离光源最近的点的位置），从而获得一张 shadow depth map。
            其实，上面的流程和普通的camera获取depth map的流程是基本一样的，只是要改换到光源位置来观察而已。 
    4、应用到场景中：利用 shadow depth map 
            获取了 shadow depth map之后，就要利用它来进行鉴别。根据第2小节的讨论，可以知道，如果某个点，
                其在光源视角下的 depth 大于 shadow map中对应位置的 depth，则意味着它被某个物体遮挡，因此是在阴影中的；反之则不在阴影之中。
            所以，对于世界中的某个点 p，我们只要将其转移到 light space ，比较他在light space下的depth，就可以判定它是否是在阴影之中了。 

5.unity动态合批，静态合批的区别： 
    Unity在 Player Setting 里的两个功能选项 Static Batching 与 Dynamic Batching。功能描述如下：
         Static Batching 是将标明为 Static 的静态物件，
         如果在使用相同材质球的条件下，Unity 会自动帮你把这两个物件合并成一个 Batch，送往 GPU 来处理。
         这功能对效能上非常的有帮助，所以是需要付费才有的。
    Dynamic Batching 是在物件小于300面的条件下(不论物件是否为静态或动态)，
        在使用相同材质球下，Unity就会自动帮你合合并成一个 Batch 送往 GPU 来处理。

4. UGUI 的优化 
    UI 资源规范（内存优化） 
    客户端做任何的性能优化首先想到的都是规范美术资源，前期不给美术资源定制一定的规范，后期做优化性能会非常的被动。对于 UI 资源的规范，主要是考虑的内存优化。
    1.任何的 UI 图集最大 size 1024*1024（内存优化）；
    2.同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放common（DrawCall 优化）；
    3.能用九宫格的尽量用九宫格来减小原图大小（内存优化）；
    4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大小是 1136*640（我们 UI 的标准分辨率），让美术按照比例高度缩小到 500，这样一张 1024*1024 的图集就可以放两张原图了，提升图集利用率。对于一些600*400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图集就是 512*512 而不是 1024*1024（内存优化）；
    5.对于特别长条的 UI 原图，例如 1000*100，如果由于加入这个长条的原图导致图集大小变大而且利用率很低的话，要把 1000*100 的原图拆分成两张图500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图集缩小到 512（内存优化）；
    6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内存优化、安装包量优化）；
    7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在使用的时候直接按需求修改顶点色即可（内存优化）；
    8.关闭 mipmaps（内存优化）。

    GPU 优化 
        谈及 GPU，我们知道它负责整个渲染流水线，从处理 CPU 传递过来的模型数据开始，
        进行 Vertex Shader、Fragment Shader 等一系列工作，最后输出屏幕上的每个像素。
        因此我们可以从两个方面着手，优化 Shader、减少 OverDraw。

    Shader 优化 
    我们的 UI Shader 是自己编写的，没有使用默认的 UI-Default.shader，因此Shader 优化非常有必要。
        1.Fog { Mode Off }，最早有一个版本我们没有关闭 Fog，导致打开全屏 UI 的时候帧率明显往下掉（我们的全屏 UI 开启后会关闭主相机，理论上渲染压力和CPU 消耗会降低），后来 Adreno Profiler 真机调式 Shader 代码后发现了此问题；
        2.Fragment 剔除掉 Alpha 为 0 的像素点，减少 OverDraw；
        3.尽量简化 Shader 代码，最早我们有一些 UI 效果的需求全都写在了一个Shader 里，其实 99%的 UI 不要这些东西，单独把效果需求代码拎出来独立一个 Shader。


    OverDraw 优化 
     在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然更多。
     目前在移动设备上，OverDraw 的压力主要来自半透明物体。因为多数情况下，半透明物体需要开启 Alpha Blend 且关闭 ZWrite，同时如果我们绘制像 alpha=0 这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是一种极大的浪费。

    我们的 UI 绘制是 Alpha Blend 且关闭 ZWrite，因此 UI OverDraw 的优化主要是在制作界面的时候减少 UI 重叠层级（和策划、美术 pk）。除此之外还是有一些我们程序可以控制的优化点：
        1.对于九宫格的 Image，如果去掉 fillcenter 不影响最后出来的效果就要把fillcenter 去掉，可以减少中间一片的像素绘制；
        2.看不见的元素且没有逻辑功能要 disable 或者挪出裁剪区域，而不要通过设置Alpha=0 来隐藏；
        3.不要使用一张 Alpha=0 的 Image 来实现放大响应区域的功能；
        4.UI 底层系统来控制隐藏看不见的元素，例如打开全屏 UI 的时候把下面看不见的 UI 挪出裁减区域、关闭主相机渲染。

    CPU 优化 
        在我们项目开发的过程中，遇到的大部分 UI 相关性能热点都是和 CPU 消耗相关的。
        大致可以分为以下几类：DrawCall、Canvas.SendWillRenderCanvases()、Canvas.BuildBatch()和其他。

    DrawCall 优化 
    DrawCall 是 CPU 调用底层图形接口，频繁的调用对 CPU 性能的影响是很明显的。优化思路很简单，合批绘制。UGUI 本身的动态合批机制会帮我们尽量的去优化合批，我们要做的就是弄清楚它的合批机制然后让 UI 元素尽量合批绘制。以下是我们项目组在制作 UI 过程中总结出来了的一些优化 Tips：
        1.合理分配图集，同一个界面上的图尽量打到一个图集，多个界面复用的图，放到 common；
        2.制作界面的时候，相邻节点尽量使用同一个图集的图片；
        3.Text 本身也是用的 Font Texture，不同字体的 Text 也是来自不同的图集，所以在布局界面的时候也要尽量避免穿插打断绘制流程；
        4.DrawCall 的数量不是完全由 Hierarchy 的布局决定，和 UI 的位置也有关系，
            这个位置不是指的 Rectranform 上面的 size 位置重叠就一定打断绘制，而是真实的三角面的位置是否重叠。这个可以在 Scene 视图下用线框模式(Texture
            Wire)去观察；
        5.少用 Mask 组件，Mask 实现的原理是 Stencil Buffer，往模版缓存里绘制，模版缓存里的东西才是可见的。
            模板缓存会打断所有的合批，Mask 的子节点和外面的节点无法合批，模板缓存自己占一个 DrawCall。
            Unity5.2 之后的版本建议使用 2D Rect Mask 替代。

5. 同步 异步 加载问题
    下面我们学习异步加载游戏场景，异步异步顾名思义就是不影响当前游戏场景的前提下加载新场景。
    通常异步加载的方式分为两种：
        第一种是异步加载新游戏场景，当新场景加载完成后进入新场景并且销毁之前的场景。
        第二种:同样异步加载新场景，新场景加载完毕后，保留旧场景的游戏对象并且进入新场景。

    同步加载 
        读取新关卡后立即切换，其参数为所读取新关卡的名称或索引。Application.LoadLevel ("关卡名或者加载场景的序号") 
        这个方法对于场景小，资源少的情况可以，要是遇到资源大的场景，就会卡，这种情况就要用到异步加载了


6. 类和接口的区别 以及相同点 
    不同点：
        接口不能直接实例化。
        接口不包含方法的实现。
        接口可以多继承，类只能单继承。
        类定义可以在不同的源文件之间进行拆分。
    相同点：
        接口、类和结构都可以从多个接口继承。
        接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。
        接口和类都可以包含事件、索引器、属性。 

7. unity 生命周期
    Awake -> onEnable -> Start -> FixUpdate -> Update -> Lateupdate -> OnGUI -> OnDiable -> OnDestroy 
    LateUpdate是在所有Update函数调用后被调用。可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。
    所以一些物理属性的更新操作应该放在FxiedUpdate中操作，比如Force，Collider，Rigidbody等。
        外设的操作也是，比如说键盘或者鼠标的输入输出Input，因为这样GameObject的物理表现的更平滑，更接近现实。