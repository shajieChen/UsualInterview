Unity 相关面试 

1. hash 相关
    1、什么是hash?
        Hash：是一种信息摘要算法，它还叫做哈希，或者散列。我们平时使用的MD5,
        SHA1都属于Hash算法，通过输入key进行Hash计算，就可以获取key的HashCode()，比如我们通过校验MD5来验证文件的完整性。
        对于HashCode，它是一个本地方法，实质就是地址取样运算 
    2、什么是碰撞？ 
        好的Hash算法可以出计算几乎出独一无二的HashCode，如果出现了重复的hashCode，就称作碰撞; 
        就算是MD5这样优秀的算法也会发生碰撞，即两个不同的key也有可能生成相同的MD5。
    3、“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” 
        HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射
        HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
        HashMap 是非 synchronized，所以 HashMap 很快
        HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）
        HashMap 是基于 hashing 的原理 
        以下是具体的 put 过程（JDK1.8）  
            对 Key 求 Hash 值，然后再计算下标
            如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）
            如果碰撞了，以链表的方式链接到后面
            如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
            如果节点已经存在就替换旧值
            如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排） 

2. GC
    能简单聊一下垃圾收集的工作方式吗？ 
        运行.NET应用程序时，程序创建出来的对象都会被CLR跟踪， 
        哪些对象还会被用到（存在引用关系）；哪些对象不会再被用到（不存在引用关系），CLR都是有记录的。 
        CLR会整理不会再被用到的对象，在恰当的时机，按一定的规则销毁一部分对象，释放出这些对象所占用的内存。
       - CLR是怎么记录对象引用关系的？ 
            CLR会把对象关系做成一个“树图”，这样标记他们的引用关系 
       - CLR是怎么释放对象的内存的？ 
            关键的技术是：CLR把没用的对象转移到一起去，使内存连续，新分配的对象就在这块连续的内存上创建，这样做是为了减少内存碎片（CLR不会移动大对象）
    垃圾收集器按什么规则收集垃圾对象？ 
        CLR按对象在内存中的存活的时间长短，来收集对象。
        时间最短的被分配到第0代，最长的被分配到第2代，一共就3代。
        一般第0贷的对象都是较小的对象，第2代的对象都是较大的对象
        第0代对象GC收集时间最短（毫秒级别），第2代的对象GC收集时间最长。
        当程序需要内存时（或者程序空闲的时），GC会先收集第0代的对象，
        收集完之后发现释放的内存仍然不够用，GC就会去收集第1代，第2代对象。（一般情况是按这个顺序收集的）
        如果GC跑过了，内存空间依然不够用，那么就抛出了OutOfMemoryException异常。
        GC跑过几次之后，第0代的对象仍然存在，那么CLR会把这些对象移动到第1代，第1代的对象也是这样。
    既然有了垃圾收集器，为什么还要Dispose方法和析构函数？ 
        因为CLR的缘故，GC只能释放托管资源，不能释放非托管资源（数据库链接、文件流等） 
        那么该如何释放非托管资源呢？
        一般我们会选择为类实现IDispose接口，写一个Dispose方法。
        让调用者手动调用这个类的Dispose方法（或者用using语句块来调用Dispose方法）
        这是不错的选择，因为调用者最清楚该什么时候来释放这些资源。
        这个方法执行时，析构函数和垃圾收集器都还没有开始处理这个对象的释放工作
    我们需要手动执行垃圾收集吗？什么场景下这么做？ 
    GC何时执行垃圾收集是一个非常复杂的算法（策略） 
        大概可以描述成这样： 
        如果GC发现上一次收集了很多对象，释放了很大的内存， 
        那么它就会尽快执行第二次回收， 
        如果它频繁的回收，但释放的内存不多， 
        那么它就会减慢回收的频率。 
        所以，尽量不要调用GC.Collect()，这样会破坏GC现有的执行策略。 
        除非你对你的应用程序内存使用情况非常了解，你知道何时会产生大量的垃圾，那么你可以手动干预垃圾收集器的工作  
        我有一个大对象，我担心GC要过很久才会收集他，
    简单聊一下弱引用和垃圾收集之间的关系？ 
        假设有一个大对象，用完之后引用关系就没有了，这个时候GC随时都有可能收集它，并释放他占用的内存 
        但因为是一个较大的对象，很有可能在第3代，估计GC一时半会还不会去收集它。 
        这个对象已经在垃圾堆里了，但是我还想用它，怎么办？怎么从垃圾堆里把它捞回来呢？ 
        这个时候就用到了弱引用，来看看下面这段代码： 
        varbss = newBsCtl(BrowserContainer);             varvbss = newWeakReference<BsCtl>(bss);             bss = null;             BsCtl ok;                         vbss.TryGetTarget(outok);             //如果没有进行垃圾收集OK不会为NULLif(ok == null)             {                 //如果已经进行了垃圾收集，就会执行这段代码ok = newBsCtl(BrowserContainer);             }
        垃圾收集随时可以收集bss对象， 
        如果收集了，就会进入if语句块，如果没有收集，就不会进入if语句块，TryGetTarget(out ok)就成功把bss从垃圾堆里捞回来了
 

3. 阴影 
     一般来说，在游戏中，应用比较多的影子技术有三种，Projective Shadow、 Shadow Map以及Shadow Volume。我们接下来便依次的介绍它们。

    1、阴影算法的任务 
        shadow map（以及shadow volume）等shadow算法，到底是做什么的？这其实是需要解决的第一个问题。这些阴影算法的核心，实际上就是要针对任意给定的一个物体片段点（fragment point），鉴定出它是否处在阴影之中。
        所以阴影算法，归根结底是要给出这样一个函数： 
        bool ShadowAlgorithm(vector3 fragmentPoint) {
            if ( IsInShadow(fragmentPoint) )
                return true;
            else
                return false;
        }
        各种不同的阴影算法，实际上就是“是否在阴影中”的鉴别方法不同。 
    2、阴影产生的自然原理 
            什么样的点是在阴影中的？看看下面这张图 
                图1、阴影（图中橘黄色的是不透明的物体） 
            在平行光的照射下，直觉的可以知道，点A、点D在阴影之外，而点B、点C在阴影之中。
                直觉判断的依据，就是由于光线的直线传播特性，一旦遇到遮挡，就会产生阴影。换言之，对于光线来说不可见的点，就是在阴影中的点。
            那么上面的判断函数 IsInShadow，就可以进一步写为如下的伪代码： 
                bool IsInShadow(vector3 fragmentPoint) {
                    return !IsVisibleToLight(fragmentPoint, mLight);
                }
            其中 mLight是需要生成阴影的平行光，fragmentPoint是需要进行判断的片段点。
    3、基于自然原理的提炼：light space 的 shadow depth map 
            一提到这种可见性的判定，自然的就会想到 depth test。我们站在光源的位置，按照光线传播的视角，观察场景，
                计算场景中的物体距离光源的距离（也就是该视角下的深度），并记录各个位置上的最小值（即距离光源最近的点的位置），从而获得一张 shadow depth map。
            其实，上面的流程和普通的camera获取depth map的流程是基本一样的，只是要改换到光源位置来观察而已。 
    4、应用到场景中：利用 shadow depth map 
            获取了 shadow depth map之后，就要利用它来进行鉴别。根据第2小节的讨论，可以知道，如果某个点，
                其在光源视角下的 depth 大于 shadow map中对应位置的 depth，则意味着它被某个物体遮挡，因此是在阴影中的；反之则不在阴影之中。
            所以，对于世界中的某个点 p，我们只要将其转移到 light space ，比较他在light space下的depth，就可以判定它是否是在阴影之中了。 



4. UGUI 的优化 
    UI 资源规范（内存优化） 
    客户端做任何的性能优化首先想到的都是规范美术资源，前期不给美术资源定制一定的规范，后期做优化性能会非常的被动。对于 UI 资源的规范，主要是考虑的内存优化。
    1.任何的 UI 图集最大 size 1024*1024（内存优化）；
    2.同一个界面出现的 UI 资源尽量放到一个图集，重复利用的公用资源放common（DrawCall 优化）；
    3.能用九宫格的尽量用九宫格来减小原图大小（内存优化）；
    4.美术给过来的 UI 原图 size 尽量小，对于一些全屏的 loading 原画图，原画大小是 1136*640（我们 UI 的标准分辨率），让美术按照比例高度缩小到 500，这样一张 1024*1024 的图集就可以放两张原图了，提升图集利用率。对于一些600*400 类似大小的原图，就尽量按比例把最长边压小到 500，这样出来的图集就是 512*512 而不是 1024*1024（内存优化）；
    5.对于特别长条的 UI 原图，例如 1000*100，如果由于加入这个长条的原图导致图集大小变大而且利用率很低的话，要把 1000*100 的原图拆分成两张图500*100，在制作界面的时候用两个 Image 拼接即可，这样可以把 1024 的图集缩小到 512（内存优化）；
    6.图集利用率低于 1/3 的时候，要考虑和其他同一个 size 的图集合并以提升利用率。合并的原则是不改变任何一个图集的大小，这样即可完全省掉一张图集（内存优化、安装包量优化）；
    7.尽量复用 UI 资源，减少不必要的原图，例如一个卡牌分了五种品质原画底图，白蓝黄绿紫，就不要使用五张大底图了，让美术同事画一个灰色原图，Image 在使用的时候直接按需求修改顶点色即可（内存优化）；
    8.关闭 mipmaps（内存优化）。

5. 同步 异步 加载问题
    下面我们学习异步加载游戏场景，异步异步顾名思义就是不影响当前游戏场景的前提下加载新场景。
    通常异步加载的方式分为两种：
        第一种是异步加载新游戏场景，当新场景加载完成后进入新场景并且销毁之前的场景。
        第二种:同样异步加载新场景，新场景加载完毕后，保留旧场景的游戏对象并且进入新场景。

    同步加载 
        读取新关卡后立即切换，其参数为所读取新关卡的名称或索引。Application.LoadLevel ("关卡名或者加载场景的序号") 
        这个方法对于场景小，资源少的情况可以，要是遇到资源大的场景，就会卡，这种情况就要用到异步加载了